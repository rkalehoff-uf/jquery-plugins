<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="description" content="">

    <link rel="stylesheet" href="css/vendor/normalize.min.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div class="container">
        <article class="article-layout hentry">
            <header class="entry-header">
                <h1 class="entry-title">Axiomatic CSS and Lobotomized Owls</h1>
                <p class="entry-details">
                    by <a class="author" rel="author" href="http://alistapart.com/author/heydonworks">Heydon Pickering</a>
                    <time class="pubdate updated" datetime="2014-10-21T10:00:00-04:00">October 21, 2014</time>
                    <span class="optional-break">Published in <a href="http://alistapart.com/topic/css">CSS</a>, <a href="http://alistapart.com/topic/html">HTML</a>·</span>
                </p>
            </header>
            <div class="main-content">
                <p>At <a href="http://cssday.nl/2014">CSS Day</a> last June I introduced, with some trepidation, a peculiar three-character CSS selector. Called the “lobotomized owl selector” for its resemblance to an owl’s vacant stare, it proved to be the most popular section of <a href="http://vimeo.com/101718785">my talk</a>. </p>
                <p>I couldn’t tell you whether the attendees were applauding the thinking behind the invention or were, instead, nervously laughing at my audacity for including such an odd and seemingly useless construct. Perhaps I was unwittingly speaking to a room full of paid-up owl sanctuary supporters. I don’t know.</p>
                <p>The lobotomized owl selector looks like this:</p>
                <pre id="snippet1"><code>* + *</code></pre>
                <p>Despite its irreverent name and precarious form, the lobotomized owl selector is no mere thought experiment for me. It is the result of ongoing experimentation into automating the layout of flow content. The owl selector is an “axiomatic” selector with a voracious purview. As such, many will be hesitant to use it, and it will terrify some that I include it in production code. I aim to demonstrate how the selector can reduce bloat, speed up development, and help automate the styling of arbitrary, dynamic content.</p>
                <h2 id="section1">Styling by prescription<a class="subhead-anchor" href="#section1">#section1</a></h2>
                <p>Almost universally, professional web interface designers (engineers, whatever) have accustomed themselves to styling HTML elements <em>prescriptively</em>. We conceive of an interface object, then author styles for the object that are inscribed manually in the markup as “hooks.”</p>
                <p>Despite only pertaining to presentation, not semantic interoperability, the class selector is what we reach for most often. While elements and most attributes are predetermined and standardized, classes are the placeholders that gift us with the freedom of authorship. Classes give us control.
                    <br>
                </p><pre id="snippet2"><code>.my-module {
    /* ... */
}</code></pre>
                <p>CSS frameworks are essentially libraries of non-standard class-based ciphers, intended for forming explicit relationships between styles and their elements. They are vaunted for their ability to help designers produce attractive interfaces quickly, and criticized for the inevitable accessibility shortcomings that result from leading with style (form) rather than content (function).
                    <br>
                </p><pre id="snippet3"><code>&lt; !-- An unfocusable, semantically inaccurate "button" --&gt;
&lt;a class="ui-button"&gt;press me&lt;/a&gt;</code></pre>
                <p>Whether you use a framework or your own methodology, the prescriptive styling mode also prohibits non-technical content editors. It requires not just knowledge of presentational markup, but also access to that markup to encode the prescribed styles. WYSIWYG editors and tools like Markdown necessarily lack this complexity so that styling does not impede the editorial process.</p>


                <h2 id="section2">Bloat<a class="subhead-anchor" href="#section2">#section2</a></h2>
                <p>Regardless of whether you can create and maintain presentational markup, the question of whether you <em>should</em> remains. Adding presentational ciphers to your previously terse markup necessarily engorges it, but what’s the tradeoff? Does this allow us to reduce bloat in the stylesheet?</p>
                <p>By choosing to style entirely in terms of named elements, we make the mistake of asserting that HTML elements exist in a vacuum, not subject to inheritance or commonality. By treating the element as “this thing that needs to be styled,” we are liable to redundantly set some values for the element in hand that should have already been defined higher in the cascade. Adding new modules to a project invites bloat, which is a hard thing to keep in check.
                    <br>
                </p><pre id="snippet4"><code>.module-new {
    /* So… what’s actually new here? */
}</code></pre>
                <p>From pre-processors with their addition of variables to object-based CSS methodologies and their application of reusable class “objects,” we are grappling with sandbags to stem this tide of bloat. It is our industry’s obsession. However, few remedies actually eschew the prescriptive philosophy that invites bloat in the first place. Some interpretations of object-oriented CSS even insist on a flattened hierarchy of styles, citing <a href="http://www.impressivewebs.com/css-specificity-irrelevant/">specificity as a problem to be overcome</a>—effectively reducing CSS to SS and denying one of its key features.</p>
                <p>I am not writing to condemn these approaches and technologies outright, but there are other methods that just may be more effective for certain conditions. Hold onto your hats.</p>


                <h2 id="section3">Selector performance<a class="subhead-anchor" href="#section3">#section3</a></h2>
                <p>I’m happy to concede that when some of you saw the two asterisks in <code>* + *</code> at the beginning of this article, you started shaking your head with vigorous disapproval. There is a precedent for that. <a href="http://meyerweb.com/eric/articles/webrev/200006a.html">The universal selector</a> is indeed a powerful tool. But it can be good powerful, not just bad powerful. Before we get into that, though, I want to address the perceived performance issue.</p>
                <p>All the studies I’ve read, including <a href="http://www.stevesouders.com/blog/2009/03/10/performance-impact-of-css-selectors/">Steve Souders’</a> and <a href="http://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/">Ben Frain’s</a>, have concluded that the comparative performance of different CSS selector types is negligible. In fact, Frain concludes that “sweating over the selectors used in modern browsers is futile.” I’ve yet to read any compelling evidence to counter these findings.</p>
                <p>According to Frain, it is, instead, the quantity of CSS selectors—the bloat—that may cause issues; he mentions unused declarations specifically. In other words, embracing class selectors for their “speed” is of little use when their proliferation is causing the real performance issue. Well, that and the giant JPEGs and un-subsetted web fonts.</p>
                <p>Contrariwise, the * selector’s simultaneous control of multiple elements increases brevity, helping to reduce file size and improve performance.</p>
                <p>The <em>real</em> trouble with the universal sector is that it alone doesn’t represent a very compelling axiom—nothing more intelligent than “style whatever,” anyway. The trick is in harnessing this basic selector and forming more complex expressions that are context-aware.</p>


                <h2 id="section4">Dispensing with margins<a class="subhead-anchor" href="#section4">#section4</a></h2>
                <p>The trouble with confining styles to objects is that not everything should be considered a property of an object <em>per se</em>. Take margins: margins are something that exist between elements. Simply giving an element a top margin makes no sense, no matter how few or how many times you do it. It’s like applying glue to one side of an object before you’ve determined whether you actually want to stick it to something or what that something might be.
                    <br>
                </p><pre id="snippet5"><code>.module-new {
    margin-bottom: 3em; /* what, all the time? */
}</code></pre>
                <p>What we need is an expression (a selector) that matches elements only in need of margin. That is, only elements in a contextual relationship with other sibling elements. The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_selectors">adjacent sibling combinator</a> does just this: using the form x + n, we can add a top margin to any n where x has come before it.</p>
                <p>This would, as with standard prescriptive styling, become verbose very quickly if we were to create rules for each different element pairing within the interface. Hence, we adopt the aforementioned universal selector, creating our owl face. The axiom is as follows: “All elements in the flow of the document that proceed other elements must receive a top margin of one line.”
                    <br>
                </p><pre id="snippet6"><code>* + * {
    margin-top: 1.5em;
}</code></pre>


                <h3 id="section5">Completeness<a class="subhead-anchor" href="#section5">#section5</a></h3>
                <p>Assuming that your paragraphs’
                    <var>font-size</var> is 1 <code>em</code> and its
                    <var>line-height</var> is 1.5, we just set a default margin of one line between all successive flow elements of all varieties occurring in any order. Neither we developers nor the folks building content for the project have to worry about any elements being forgotten and not adopting at least a standard margin when rendered one after the other. To achieve this the prescriptive way, we’d have to anticipate specific elements and give them individual margin values. Boring, verbose, and liable to be incomplete.</p>
                <p>Instead of writing styles, we’ve created a style axiom: an overarching principle for the layout of flow content. It’s highly maintainable, too; if you change the
                    <var>line-height</var>, just change this singular
                    <var>margin-top</var> value to match.</p>


                <h3 id="section6">Contextual awareness<a class="subhead-anchor" href="#section6">#section6</a></h3>
                <p>It’s better than that, though. By applying margin between elements only, we don’t generate any redundant margin (exposed glue) destined to combine with the padding of parent elements. Compare solution (a), which adds a top margin to all elements, with solution (b), which uses the owl selector.
                    <br>
                </p>
                <figure id="figure1">
                    <img src="img/owl_1.png" alt="Diagram showing elements with margins, with and without the owl selector.">
                    <figcaption>The diagrams in the left column show margin in dark grey and padding in light gray.</figcaption>
                </figure>
                <p>Now consider how this behaves in regard to nesting. As illustrated, using the owl selector and just a margin-top value, no first or last element of a set will ever present redundant margin. Whenever you create a subset of these elements, by wrapping them in a nested parent, the same rules that apply to the superset will apply to the subset. No margin, regardless of nesting level, will ever meet padding. With a sort of algorithmic elegance, we protect against compound whitespace throughout our interface.</p>
                <figure id="figure2">
                    <img src="img/owl_2.png" alt="Diagram showing nested elements with margins using the owl selector.">
                </figure>
                <p>This is eminently less verbose and more robust than approaching the problem unaxiomatically and removing the leftover glue <em>after the fact</em>, as Chris Coyier reluctantly proposed in “<a href="http://css-tricks.com/spacing-the-bottom-of-modules/">Spacing The Bottom of Modules</a>”. It was this article, I should point out, that helped give me the idea for the lobotomized owl.
                    <br>
                </p><pre id="snippet7"><code>.module &gt; *:last-child,
.module &gt; *:last-child &gt; *:last-child,
.module &gt; *:last-child &gt; *:last-child &gt; *:last-child {
    margin: 0;
}</code></pre>
                <p>Note that this only works having defined a “module” context (a big ask of a content editor), and requires estimating possible nesting levels. Here, it supports up to three.</p>


                <h2 id="section7">Exception-driven design<a class="subhead-anchor" href="#section7">#section7</a></h2>
                <p>So far, we’ve not named a single element. We’ve simply written a rule. Now we can take advantage of the owl selector’s <a href="http://css-tricks.com/specifics-on-css-specificity/">low specificity</a> and start judiciously building in exceptions, taking advantage of the cascade rather than condemning it as other methods do.</p>
                <h3 id="section8">Book-like, justified paragraphs<a class="subhead-anchor" href="#section8">#section8</a></h3>
                <pre id="snippet8"><code>p {
    text-align: justify;
}

p + p {
margin-top: 0;
text-indent: 2em;
}</code></pre>
                <p>Note that only successive paragraphs are indented, which is conventional—another win for the adjacent sibling combinator.</p>


                <h3 id="section9">Compact modules<a class="subhead-anchor" href="#section9">#section9</a></h3>
                <pre id="snippet9"><code>.compact * + * {
    margin-top: 0.75em;
}</code></pre>
                <p>You can employ a little class-based object orientation if you like, to create a reusable style for more compact modules. In this example, all elements that need margin receive a margin of only half a line.</p>


                <h3 id="section10">Widgets with positioning<a class="subhead-anchor" href="#section10">#section10</a></h3>
                <pre id="snippet10"><code>.margins-off &gt; * {
    margin-top: 0;
}</code></pre>
                <p>The owl selector is an expressive selector and will affect widgets like maps, where everything is positioned exactly. This is a simple off switch. Increasingly, widgets like these will occur as web components where our margin algorithm will not be inherited anyway. This is thanks to <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/">the style encapsulation feature of Shadow DOM</a>.</p>


                <h2 id="section11">The beauty of <code>em</code>s<a class="subhead-anchor" href="#section11">#section11</a></h2>
                <p>Although a few exceptions are inevitable, by harnessing the <code>em</code> unit in our margin value, margins already adjust automatically according to another property:
                    <var>font-size</var>. In any instances that we adjust
                    <var>font-size</var>, the margin will adapt to it: one-line spaces remain one-line spaces. This is especially helpful when setting an increased or reduced body
                    <var>font-size</var> via a <code>@media</code> query.</p>
                <p>When it comes to headings, there’s still more good fortune. Having set heading font sizes in your stylesheet in <code>em</code>s, appropriate margin (leading whitespace) for each heading has been set without you writing a single line of additional code.</p>
                <figure id="figure3">
                    <img src="img/owl_3.png" alt="Diagram showing automatically adjusted margins based on font-size.">
                </figure>


                <h2 id="section12">Phrasing elements<a class="subhead-anchor" href="#section12">#section12</a></h2>
                <p>This style declaration is intended to be inherited. That is how it, and CSS in general, is designed to work. However, I appreciate that some will be uncomfortable with just how voracious this selector is, especially after they have become accustomed to avoiding inheritance wherever possible.</p>
                <p>I have already covered the few exceptions you may wish to employ, but, if it helps further, remember that phrasing elements with a typical display value of <code>inline</code> will inherit the top margin but be unaffected in terms of layout. Inline elements only respect horizontal margin, which is as specified and standard behavior across all browsers.</p>
                <figure id="figure4">
                    <img src="img/owl_4.png" alt="Diagram showing inline elements with margin.">
                </figure>
                <p>If you find yourself overriding the owl selector frequently, there may be deeper systemic issues with the design. The owl selector deals with flow content, and flow content should make up the majority of your content. I don’t advise depending heavily on positioned content in most interfaces because they break implicit flow relationships. Even grid systems, with their floated columns, should require no more than a simple <code>.row &gt; *</code> selector applying <code>margin-top: 0</code> to reset them.</p>
                <figure id="figure5">
                    <img src="img/owl_5.png" alt="Diagram showing floated columns with margins.">
                </figure>


                <h2 id="section13">Conclusion<a class="subhead-anchor" href="#section13">#section13</a></h2>
                <p>I am a very poor mathematician, but I have a great fondness for <a href="http://en.wikipedia.org/wiki/Euclidean_geometry#Axioms">Euclid’s postulates</a>: a set of irreducible rules, or axioms, that form the basis for complex and beautiful geometries. Thanks to Euclid, I understand that even the most complex systems must depend on foundational rules, and CSS is no different. Although modularization of a complex interface is a necessary step in its maturation, any interface that does not follow basic governing tenets is going to lack clarity.</p>
                <p>The owl selector allows you to control flow content, but it is also a way of relinquishing control. By styling elements according to context and circumstance, we accept that the structure of content is—and should be—mutable. Instead of prescribing the appearance of individual items, we build systems to anticipate them. Instead of prescribing the appearance of the interface as a whole, we let the content determine it. We give control back to the people who would make it.</p>
                <p>When turning off CSS for a webpage altogether, you should notice two things. First, the page is unfalteringly flexible: the content fits the viewport regardless of its dimensions. Second—provided you have written standard, accessible markup—you should see that the content is already styled in a way that is, if not highly attractive, then reasonably traversable. The browser’s user agent styles take care of that, too. </p>
                <p>Our endeavors to reclaim and enhance the innate device independence offered by user agents are ongoing. It’s time we worked on reinstating content independence as well.</p>
            </div>
            <footer class="entry-footer">
                <h1>About the Author</h1>
                <div class="byline author vcard">
                    <h2><a class="fn" href="http://alistapart.com/author/heydonworks">Heydon Pickering</a></h2>
                    <div class="author-bio">
                        <p>Heydon Pickering is a designer and interface developer from Norwich in the UK. He is lead designer at <a href="https://www.neontribe.co.uk/">Neontribe</a> and the accessibility editor for Smashing Magazine, where his book <a href="https://shop.smashingmagazine.com/apps-for-all-coding-accessible-web-applications.html">Apps For All</a> is also available.</p>
                    </div>
                </div>
            </footer>
        </article>
    </div>

    <script src="js/jquery-2.1.4.min.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
